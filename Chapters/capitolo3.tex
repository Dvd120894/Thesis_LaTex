\chapter{Algoritmi}
\label{Geom_Algos}
%
\section{Parsificazione}
%
\subsection{Introduzione}
La parsificazione o analisi sintattica è un processo che analizza un flusso continuo di dati in ingresso (letti per esempio da un file o una tastiera) in modo da determinare la correttezza della sua struttura grazie ad una data grammatica formale. Un \textit{parser} è un programma che esegue questo compito. Nella maggior parte dei casi, l'analisi sintattica opera su una sequenza di \textit{token} in cui l'analizzatore lessicale spezzetta l'input.
%
\subsection{Parsificazione del formato RDF}
Nel lavoro svolto è stato creato un algoritmo per pardificare i file di tipo \ac{RDF} che descrivono superfici complesse. Purtroppo, come precedentemente detto, non esiste uno standard universalmente riconosciuto per questo formato. Creare dunque un \textit{parser} o definire un generatore di parser è arduo. Si è quindi optato per la creazione di un \textit{parser} che rilevi solo i nodi (\texttt{[NODES]}), li salvi temporaneamente e, dopo aver immagazzinato anche i dati relativi agli elementi (\texttt{[ELEMENTS]}), instanzi un oggetto \textit{mesh}, composto dai nodi dichiarati nella sezione elementi. Gli altri parametri non sono stati considerati.\\

Come verrà richiamato nelle conclusioni, l'importanza di definire uno standard per il formato \ac{RDF} è di cruciale importanza. In questo modo si potrà creare un generatore di parser con una grammatica e un lessico ben definiti, nonché aumentarne l'efficienza e la stabilità.
%
%
\section{\textit{Bounding Volume Hierarchy}}
%
\subsection{Introduzione}
Una \ac{BVH} è una struttura ad albero su un insieme di oggetti geometrici. Tutti gli oggetti geometrici sono raccolti in volumi limite che formano i nodi fogliari dell'albero. Questi nodi vengono quindi raggruppati come piccoli insiemi e racchiusi in volumi di delimitazione più grandi. Questi, a loro volta, sono ancora raggruppati e racchiusi in altri volumi di delimitazione più grandi in modo ricorsivo, risultando infine in una struttura ad albero con un singolo volume di delimitazione nella parte superiore dell'albero. Le gerarchie di volumi limitanti vengono utilizzate per supportare in modo efficiente diverse operazioni su insiemi di oggetti geometrici, come ad esempio il rilevamento delle collisioni.

Sebbene il \textit{wrapping} degli oggetti nei volumi di delimitazione e l'esecuzione di test di collisione su di essi prima del test della geometria dell'oggetto stesso semplifichino i test e possano comportare miglioramenti significativi delle prestazioni, è ancora in corso lo stesso numero di test a coppie tra volumi di delimitazione. Organizzando i volumi di delimitazione in una gerarchia di volumi di delimitazione, la complessità temporale (il numero di test eseguiti) può essere ridotta logaritmicamente nel numero di oggetti. Con una tale gerarchia in atto, durante i test di collisione, i volumi secondari non devono essere esaminati se i loro volumi principali non sono intersecati.
%
\subsection{\textit{Minimum Bounding Box}}
In geometria, il rettangolo minimo o più piccolo (o \ac{MBB}) per racchiudere un insieme di punti $S$ in $N$ dimensioni è l'rettangolo con la misura più piccola (area, volume o ipervolume in dimensioni superiori) all'interno del quale si trovano tutti i punti.  Il termine "iper-rettangolo (o più semplicemente \textit{box}) deriva dal suo utilizzo nel sistema di coordinate cartesiane, dove viene effettivamente visualizzato come un rettangolo (caso bidimensionale), parallelepipedo rettangolare (caso tridimensionale), ecc. Nel caso bidimensionale viene chiamato rettangolo di delimitazione minimo.
%
\subsubsection{\textit{Axis Aligned Bounding Box}}
Il \ac{MBB} allineato agli'assi (\ac{AABB}) per un determinato set di punti è il rettangolo di delimitazione minimo soggetto al vincolo che i bordi del rettangolo sono paralleli agli assi cartesiani. È il prodotto cartesiano di $N$ intervalli ciascuno dei quali è definito da un valore minimo e un valore massimo della coordinata corrispondente per i punti in $S$.

I rettangoli di delimitazione minimi allineati all'asse vengono utilizzati per determinare la posizione approssimativa di un oggetto e come descrittore molto semplice della sua forma. Ad esempio, nella geometria computazionale e nelle sue applicazioni quando è necessario trovare intersezioni nel set di oggetti, il controllo iniziale sono le intersezioni tra i loro \ac{MBB}. Dato che di solito è un'operazione molto meno costosa del controllo dell'intersezione effettiva (perché richiede solo confronti di coordinate), consente di escludere rapidamente i controlli delle coppie che sono molto distanti.

\begin{figure}[h]
	\centering
	\includegraphics[width=\linewidth]{Figures/AABB}
	\caption{Esempio di albero di tipo AABB.}
	\label{AABB}
\end{figure}
%
\subsubsection{\textit{Arbitrarily Oriented Bounding Box}}
Il \ac{MBB} orientato arbitrariamente (\ac{AOBB}) è il rettangolo di delimitazione minimo, calcolato senza vincoli per quanto riguarda l'orientamento del risultato. Gli algoritmi del rettangolo di delimitazione minimo basati sul metodo dei calibri rotanti possono essere utilizzati per trovare l'area di delimitazione dell'area minima o del perimetro minimo di un poligono convesso bidimensionale in tempo lineare e di un punto bidimensionale impostato nel tempo impiegato costruire il suo scafo convesso seguito da un calcolo del tempo lineare. Un algoritmo di pinze rotanti tridimensionali può trovare il rettangolo di delimitazione orientato arbitrariamente sul volume minimo di un punto tridimensionale impostato in tempo cubo.
%
\subsubsection{\textit{Object Oriented Bounding Box}}
Nel caso in cui un oggetto abbia un proprio sistema di coordinate locale, può essere utile memorizzare un rettangolo di selezione relativo a questi assi, che non richiede alcuna trasformazione quando cambia l'orientazione dell'oggetto stesso.

\subsection{Intersezione tra Alberi AABB}
Per il rilevamento delle collisioni tra oggetti in due dimensioni, l'intersezione tra alberi di tipo \ac{AABB}, è l'algoritmo più veloce per determinare se le due entità di gioco si sovrappongono o meno, e in che parti. Nello specifico, ciò consiste nel controllare le posizioni delle \textit{i}-esime \ac{BB} nello spazio delle coordinate bidimensionali per vedere se si sovrappongono.

Il vincolo di allineamento dei rettangoli agli assi è presente per motivi di prestazioni, infatti, l'area di sovrapposizione tra due riquadri non ruotati può essere controllata solo con confronti logici. Mentre i riquadri ruotati richiedono ulteriori operazioni trigonometriche, che sono più lente da calcolare. Inoltre, se si hanno entità che possono ruotare, le dimensioni dei rettangoli e/o sotto-rettangoli dovranno modificarsi in modo da avvolgere ancora l'oggetto o si dovrà optare per un altro tipo di geometria di delimitazione, come le sfere (che sono invarianti alla rotazione).

Nel caso specifico, l'ombra dello pneumatico sarà rappresentata da un albero di tipo \ac{AABB} con una sola foglia. Ovvero si andrà a rappresentare lo pneumatico con una \ac{BB} avente lati uguali e rappresentanti il massimo ingombro che può avere nello spazio. Si andrà inoltre ad incrementare del 10\% ognuno di questi lati in modo da tenere conto dell'angolo di camber, che portrebbe portare i punti di campionamento del terreno fuori dall'ombra. La strada, contrariamente al pneumatico, verrà tenuta come riferimento assoluto. In altre parole, una volta effettuato la parsificazione del file \ac{RDF}, verrà calcolato l'albero di tipo \ac{AABB}. Lo pneumatico si muoverà all'interno della \textit{mesh} e la sua ombra verrà ricalcolata e intersecata con l'albero \ac{AABB} per ottenere tutti i triangoli in corrispondenza della stessa.

Volendo intersecare due semplici \ac{BB}, quali $A = \left[ \texttt{A.minX}, \texttt{A.maxX} ;  \texttt{A.minY}, \texttt{A.maxY} \right]$ e $B = \left[ \texttt{B.minX}, \texttt{B.maxX} ;  \texttt{B.minY}, \texttt{B.maxY} \right]$, verrà usata la seguente funzione.
\vspace{.8em}
\begin{pseudoc}
	function intersect(A,B) {
		return (A.minX <= B.maxX && A.maxX >= B.minX) &&
					 (A.minY <= B.maxY && A.maxY >= B.minY)
	}
\end{pseudoc}
\vspace{.5em}
\noindent
Volendo intersecare un albero di tipo \ac{AABB} e una semplice \ac{BB}, basterà ripetere a più step la funzione precedente lungo i rami dell'albero. Una volta arrivati a una o più foglia avremo tutti gli oggetti (o triangoli nel caso specifico) che sono posti in corrispondenza della \ac{BB} (od ombra dello pneumatico nel caso specifico). Questi triangoli verranno poi usati per determinare il piano strada locale e il punto di contatto virtuale dello pneumatico.

È imporatante notare che il metodo appena visto, presenta numerosi vantaggi.
\begin{itemize}
	\item Riduzione del numero di comparazioni da effettuare per ottenere l'intersezione \ac{BB}-albero \ac{AABB}. Infatti, la \textit{mesh} può contenere decine di migliaia di trangoli, il metodo presentato consente di ridurre logarirmicamente il numero di comparazioni necessarie per ottenere il risultato.
	\item Riduzione del numero di trangoli da processare per ottenere il piano strada locale e il punto di contatto virtuale dello pneumatico. Infatti, vengono solamente processati quelli posti in corrispondenza del'ombra dello pneumatico.
\end{itemize}
%
\section{Algoritmi Geometrici}
%
\subsection{Introduzione}
La geometria computazionale è la branca dell'informatica che studia le strutture dati e gli algoritmi efficienti per la soluzione di problemi di natura geometrica e la loro implementazione al calcolatore. Storicamente, è considerato uno dei campi più antichi del calcolo, anche se la geometria computazionale moderna è uno sviluppo recente. La ragione principale per lo sviluppo della geometria computazionale è stata dovuta ai progressi compiuti nella computer grafica, \ac{CAD}, \ac{CAM} e nella visualizzazione matematica. Ad oggi, le applicazioni della geometria computazionale si trovano nella robotica, nella progettazione di circuiti integrati, nella visione artificiale, in \ac{CAE} e nel \ac{GIS}. I rami principali della geometria computazionale sono:
\begin{itemize}
	\item \textit{Calcolo combinatorio} (o \textit{geometria algoritmica}), che si occupa di oggetti geometrici come entità discrete. Ad esempio, può essere utilizzato per determinare il poliedro o il poligono più piccolo che contiene tutti i punti forniti, o più formalmente, dato un insieme di punti, si deve determinare il più piccolo insieme convesso che li contenga tutti (problema dell'inviluppo convesso).
	\item \textit{Geometria di calcolo} numerica (o \ac{CAGD}), che si occupa principalmente di rappresentare oggetti del mondo reale in forme adatte per i calcoli informatici nei sistemi \ac{CAD} e \ac{CAM}. Questo ramo può essere visto come uno sviluppo della geometria descrittiva ed è spesso considerato un ramo della computer grafica o del \ac{CAD}. Entità importanti di questo ramo sono superfici e curve parametriche, come ad esempio le \textit{spline} e \textit{curve di Bézier}.
\end{itemize}

In questo capitolo tutti gli algoritmi che verranno utilizzati in seguito durante l'analisi geometrica dell'intersezione tra pneumatico e superficie stradale saranno trattati. Questi algoritmi sono la soluzione di alcuni semplici ma molto importanti problemi, che devono essere risolti in modo efficiente. In particolare le intersezioni tra:
\begin{itemize}
	\item punto e segmento (sul piano);
	\item punto e circonferenza (sul piano);
	\item raggio e circonferenza (sul piano);
	\item raggio e triangolo (sullo spazio);
\end{itemize}
saranno esaminati al fine di trovare la massima prestazione in termini di efficienza computazionale.
%
\subsection{Intersezione tra Entità Geometriche}
%
\subsubsection{Punto-Segmento}
Dato un punto $P = (x_p, y_p)$ e un segmento definito da due punti $A = (x_A, y_B)$ e $B = (x_B, y_B)$.

\begin{figure}[h!]
	\centering
	\begin{tikzpicture}
	\def\r{2};
	\coordinate (P) at (0.3,0.7);
	\coordinate (A) at (-2.0,0.0);
	\coordinate (B) at (+2.0,0.0);
	\draw[fill] (A) circle [radius=1pt] node[above] {$A$};
	\draw[fill] (B) circle [radius=1pt] node[above] {$B$};
	\draw[fill] (P) circle [radius=1pt] node[above] {$P$};
	\draw[thick](A) -- (B);
	\end{tikzpicture}
	\caption{Schema grafico per l'intersezione punto-segmento}
\end{figure}
\noindent
Per determinare se il punto $P$ è intermo al segmento si eseguiranno i seguenti step.
\begin{enumerate}
	\item Creazione di un vettore $\vv{AB}$ e di un vettore $\vv{AP}$.
	\item Calcolo il prodotto vettoriale  $\vv{P_1P_2} \times  \vv{PP_1}$, se il modulo del vettore risultante è nullo allora il punto $P$ appartiene al segmento considerato.
	\item Calcolo il prodotto scalare tra $\vv{AB}$ e $\vv{AP}$. Se è nullo allora il punto $P$ è coincidente a $A$, se è pari al modulo di $\vv{AB}$ allora il punto $P$ è coincidente a $B$, se è compreso tra 0 il modulo di $\vv{AB}$, allora il punto $P$ giace all'interno del segmento considerato.
\end{enumerate}
Il codice che esegue questo tipo di test è riportato in \figurename{ \ref{pointsegment}}

\begin{figure}[h!]
	\hfill
	\begin{subfigure}{.45\textwidth}
		\centering
		\begin{tikzpicture}
		\coordinate (P0) at (0.3,0.7);
		\coordinate (P3) at (-0.7,0);
		\coordinate (A) at (-2.0,0.0);
		\coordinate (B) at (+2.0,0.0);
		\draw[fill] (P0) circle [radius=1pt] node[above] {\texttt{0}};
		\draw[fill] (A) circle [radius=1pt] node[above] {\texttt{1}};
		\draw[fill] (B) circle [radius=1pt] node[above] {\texttt{2}};
		\draw[fill] (P3) circle [radius=1pt] node[above] {\texttt{3}};
		\draw[thick](A) -- (B);
		\end{tikzpicture}
		\caption{\textit{Output} di tipo \texttt{integer}}
	\end{subfigure}
	\hfill
	\begin{subfigure}{.45\textwidth}
		\centering
		\begin{tikzpicture}
		\coordinate (P0) at (0.3,0.7);
		\coordinate (P3) at (-0.7,0);
		\coordinate (A) at (-2.0,0.0);
		\coordinate (B) at (+2.0,0.0);
		\draw[fill] (P0) circle [radius=1pt] node[above] {\texttt{false}};
		\draw[fill] (A) circle [radius=1pt] node[above] {\texttt{true}};
		\draw[fill] (B) circle [radius=1pt] node[above] {\texttt{true}};
		\draw[fill] (P3) circle [radius=1pt] node[above] {\texttt{true}};
		\draw[thick](A) -- (B);
		\end{tikzpicture}
		\caption{\textit{Output} di tipo \texttt{bool}}
	\end{subfigure}
	\hfill
	\caption{Schemi per l'\textit{output} dell'intersezione punto-segmento.}
\end{figure}
\begin{figure}[h!]
	\hfill
	\begin{subfigure}[t]{.45\linewidth}
	\raggedright
	\textit{Output} di tipo \texttt{integer}\\
	\vspace{.5em}
	\begin{pseudoc}
	if ( AB.cross(AP) > epsilon )
		{ return 0; }
	KAP = AB.dot(AP);
	if ( KAP < -epsilon )
		{ return 0; }
	if ( abs(KAP) < epsilon  )
		{ return 1; }
	KAB = AB.dot(AB);
	if ( KAP > KAB )
		{ return 0; }
	if ( abs(KAP-KAB) < epsilon )
		{ return 2; }
	return 3;
	\end{pseudoc}
	\end{subfigure}
	\hfill
	\begin{subfigure}[t]{.45\textwidth}
	\raggedright
	\textit{Output} di tipo \texttt{bool}\\
	\vspace{.5em}
	\begin{pseudoc}
	if ( AB.cross(AP) > epsilon )
		{ return false; }
	KAP = AB.dot(AP);
	if ( KAP < -epsilon )
		{ return false; };
	if ( abs(KAP) < epsilon )
		{ return true; }
	KAB = AB.dot(AB);
	if ( KAP > KAB ) 
		{ return false; }
	if ( abs(KAP-KAB) < epsilon )
		{ return true; }
	return true;
	\end{pseudoc}
	\end{subfigure}
	\hfill
	\caption{Schema del codice per l'intersezione punto-segmento.}
	\label{pointsegment}
\end{figure}
%
\subsubsection{Punto-Cerchio}
Data una circonferenza con centro $C = (x_c, y_c)$ e raggio $r$, il problema consiste nel trovare se un punto generico $P = (x_p, y_p)$ è locato all'interno, all'esterno o sulla circonferenza.
\begin{figure}[h]
	\centering
	\begin{tikzpicture}
	\def\r{2};
	\coordinate (C) at (0,0) node[above left] {$C$};
	\draw[thick, fill=gray!10](C) circle (\r);
	\coordinate (P) at (-0.5,-1.5);
	\draw[fill] (C) circle [radius=1pt];
	\draw[fill] (P) circle [radius=1pt];
	\draw(C) -- (P)  node[above left] {$P$} node[pos=0.5, right] {$d$};
	\draw(C) -- ({sqrt(\r)},{sqrt(\r)}) node[pos=0.4, above] {$r$};
	\end{tikzpicture}
	\caption{Schema del problema di intersezione punto-cerchio.}
\end{figure}
La soluzione al problema è semplice: la distanza tra il centro del cerchio $C$ e il punto $P$ è data dal teorema di Pitagora. In particolare:
\begin{equation}
	d=\sqrt{(x_p-x_c)^2 + (y_p-y_c)^2}
\end{equation}
il punto $P$ è dunque interno alla circonferenza se $d<r$, appartiene alla circonferenza se $d=r$ ed esterno alla circonferenza se $d>r$. In maniera analoga ma più efficace da punto di vista computazionale si può confrontare $d^2$ con $r^2$. Il punto $P$ è dunque interno alla circonferenza se $d^2<r^2$,  appartiene alla circonferenza se $d^2=r^2$ ed esterno alla circonferenza se $d^2>r^2$. Pertanto, il confronto finale sarà tra il numero $(x_p-x_c)^2+(y_p-y_c)^2 $ e $r^2$.

\noindent
Gli \textit{inputs} dell'algoritmo per l'intersezione punto-cerchio sono:
\begin{itemize}
	\item il centro della circonferenza $C = (x_c, y_c)$;
	\item il raggio della circonferenza $r$;
	\item il punto generico da analizzare $P=(x_p, y_p)$.
\end{itemize}
L'\textit{output} può essere un intero il cui valore può essere:
\begin{itemize}
	\item \texttt{0} se il punto è esterno;
	\item \texttt{1} se il punto è interno;
	\item \texttt{2} se il punto appartiene alla circonferenza.
\end{itemize}
Il valore in \textit{output} può essere anche una variabile booleana il cui valore è:
\begin{itemize}
	\item \texttt{false} se il punto è esterno;
	\item \texttt{true} se il punto è interno o appartiene alla circonferenza.
\end{itemize}
%
\begin{figure}[h]
\hfill
	\begin{subfigure}{.45\textwidth}
	\centering
	\begin{tikzpicture}
	\def\r{2};
	\coordinate (C) at (0,0);
	\draw[thick, fill=gray!10](C) circle (\r);
	\draw[fill] (0,-0.5) circle [radius=1pt] node[above left] {\texttt{1}};
	\draw[fill] (-\r,0) circle [radius=1pt] node[above left] {\texttt{2}};
	\draw[fill] (3,0) circle [radius=1pt] node[above left] {\texttt{0}};
	\end{tikzpicture}
	\caption{\textit{Output} di tipo \texttt{integer}}
\end{subfigure}
\hfill
\begin{subfigure}{.45\textwidth}
	\centering
	\begin{tikzpicture}
	\def\r{2};
	\coordinate (C) at (0,0);
	\draw[thick, fill=gray!10](C) circle (\r);
	\draw[fill] (0,-0.5) circle [radius=1pt] node[above left] {\texttt{true}};
	\draw[fill] (-\r,0) circle [radius=1pt] node[above left] {\texttt{true}};
	\draw[fill] (3,0) circle [radius=1pt] node[above] {\texttt{false}};
	\end{tikzpicture}
	\caption{\textit{Output} di tipo \texttt{bool}}
\end{subfigure}
\hfill
\caption{Schemi per l'\textit{output} dell'intersezione punto-cerchio.}
\end{figure}
\begin{figure}[h]
\hfill
	\begin{subfigure}[t]{.475\linewidth}
	\raggedright
	\textit{Output} di tipo \texttt{integer}\\
	\vspace{.5em}
	\begin{pseudoc}
	d = (x_p-x_c)^2 + (y_p-y_c)^2;
	if ( d > r^2 ){ return  0; }
	else if ( d < r^2 ){ return 1; }
	else { return 2; }
	\end{pseudoc}
	\end{subfigure}
\hfill
	\begin{subfigure}[t]{.475\textwidth}
	\raggedright
	\textit{Output} di tipo \texttt{bool}\\
	\vspace{1em}
	\begin{pseudoc}
	d = (x_p-x_c)^2 + (y_p-y_c)^2;
	if ( d > r^2 ){ return  true; }
	else { return false; }
	\end{pseudoc}	
	\end{subfigure}
\hfill
\caption{Schemi del codice per l'intersezione punto-cerchio.}
\label{Pointcircle}
\end{figure}
%
\subsubsection{Piano-Piano}
Nello spazio delle coordinate tridimensionali, due piani $P_1$ e $P_2$ o sono paralleli o si intersecano creando una singola retta $L$. Sia $P_i$ con $i = 1,2$ descritto da un punto $V_i$ e un vettore normale $\vec{n}_i$. L'equazione implicita del piano sarà dunque:
\begin{equation}
\vec{n}_i \cdot P + d_i = 0
\end{equation}
dove $P = (x, y, z)$. I piani $P_1$ e $P_2$ sono paralleli ogni volta che i loro normali vettori $\vec{n}_1$ e $\vec{n}_2$ sono paralleli. Questo equivale alla condizione che $\vec{n}_1 \times \vec{n}_2 = 0$. Quando i piani non sono paralleli, $\vec{u} = \vec{n}_1 \times \vec{n}_2$ è il vettore di direzione della linea di intersezione $L$. Si noti che $\vec{u}$ è perpendicolare sia a $\vec{n}_1$ che a $\vec{n}_2$, e quindi è parallelo a entrambi i piani.

Dopo aver calcolato $\vec{n}_1 \times \vec{n}_2$, per determinare univocamente la linea di intersezione, è necessario trovare un punto di essa. Cioè, un punto $P_0 = (x_0, y_0, z_0)$ che si trova in entrambi i piani. Si può trovare una soluzione comune delle equazioni implicite per $P_1$ e $P_2$. Ma ci sono solo due equazioni nelle 3 incognite poiché il punto $P_0$ può trovarsi ovunque sulla linea monodimensionale $L$. Quindi è necessario aggiungere un altro vincolo da risolvere per un $P_0$ specifico. Esistono diversi modi per farlo, il più semplice è attraverso l'aggiunta dei un terzo piano $P_3$ avente equazione implicita $\vec{n}_3 \cdot P = 0$ dove $\vec{n}_3 = \vec{n}_1 \times \vec{n}_2$ e $d_3 = 0$ (ovvero passa attraverso l'origine). Questo metodo è funzionante poiché: 
\begin{itemize}
	\item $L$ è perpendicolare a $P_3$ e quindi lo interseca;
	\item i vettori $\vec{n}_1$, $\vec{n}_2$ e $\vec{n}_3$ sono linearmente indipendenti.
\end{itemize}
Pertanto i piani $P_1$, $P_2$ e $P_3$ si intersecano in un unico punto $P_0$ che deve trovarsi su $L$. 

Nello specifico, la formula per l'intersezione di 3 piani è:
\begin{equation}
P_0 =  \frac{-d_1(\vec{n}_2 \times \vec{n}_3) - d_2(\vec{n}_3 \times \vec{n}_1) - d_3(\vec{n}_1 \times \vec{n}_2)}{\vec{n}_1 \cdot (\vec{n}_2 \times \vec{n}_3)}
\end{equation}
e ponendo $d_3 = 0$ per $P_3$, si otteniene:
\begin{equation}
P_0 =  \frac{-d_1(\vec{n}_2 \times \vec{n}_3) - d_2(\vec{n}_3 \times \vec{n}_1)}{\vec{n}_1 \cdot (\vec{n}_2 \times \vec{n}_3)}
=
\frac{(d_2\vec{n}_1 - d_1\vec{n}_2) \times \vec{n}_3)}{(\vec{n}_1 \times \vec{n}_2) \cdot \vec{n}_3}
=
\frac{(d_2\vec{n}_1 - d_1\vec{n}_2) \times \vec{u})}{|\vec{u}|^2}
\end{equation}
e l'equazione parametrica per la retta $L$ sarà:
\begin{equation}
L(s) =
\frac{(d_2\vec{n}_1 - d_1\vec{n}_2) \times \vec{u})}{|\vec{u}|^2}+s\vec{u}
\end{equation}
dove $\vec{u}=\vec{n}_1 \times \vec{n}_2$.
%
\subsubsection{Piano-Segmento}
%
\subsubsection{Piano-Triangolo}
%
\subsubsection{Raggio-Triangolo}
Dato un triangolo avente vertici $(A,B,C)$ e un raggio $R$ con origine $R_O$ e direzione $R_D$, il problema consiste nel capire se il raggio colpisce o meno il triangolo e, in tal caso, trovare il punto di intersezione $P$.
%
\begin{figure}[htbp]
	\centering
	\begin{tikzpicture}
	\coordinate [label=left:$A$] (A) at (-1,-0.5);
	\coordinate [label=above:$B$] (B) at (1,1);
	\coordinate [label=right:$C$] (C) at (2.2,-1);
	\draw[fill=gray!10] (A) -- (B) -- (C) -- (A);
	\def\xp{0.4};
	\def\yp{-0.2};
	\def\xd{-1};
	\def\yd{1};
	\def\mag{1.7};
	\coordinate [label=above right:$P$] (P) at (\xp,\yp);
	\coordinate [label={[shift={(0.1,0.1)}]$R_D$}] (RD) at (\xp+\xd,\yp+\yd);
	\coordinate [label=above:$R_O$] (RO) at (\xp+\xd*\mag,\yp+\yd*\mag);
	\draw[fill] (P) circle [radius=1pt];
	\draw[fill] (RO) circle [radius=1pt];
	\draw[-stealth] (RO) -- (RD);
	\draw[dashed] (RD) -- (P);
	\end{tikzpicture}
	\caption{Rappresentazione del problema di intersezione raggio-triangolo.}
\end{figure}
%
Negli ultimi decenni, sono stati proposti numerosi algoritmi per risolvere questo problema, esistono quindi diverse soluzioni al problema di intersezione raggio-triangolo. Tre degli algoritmi più importanti sono:
\begin{itemize}
	\item l'agoritmo di \textit{Badouel};
	\item l'agoritmo di \textit{Segura};
	\item l'agoritmo di \textit{M\"oller} e \textit{Trumbore}.
\end{itemize}
\noindent
Come \citeauthor{RayTriangle} afferma in \cite{RayTriangle}, l'algoritmo di M\"oller-Trumbore's è il più veloce quando il piano normale e/o il piano di proiezione non sono stati precedentemente memorizzati, come nel caso specifico di questa tesi.

La teoria alla base di questo algoritmo è spiegata estensivamente in \cite{Moller}. In particolare, l'algoritmo sfrutta la parametrizzazione di $P$, il punto di intersezione, in termini delle coordinate baricentriche, ovvero:
\begin{equation}
	P = wA + uB + vC
\end{equation}
Dato che $w = 1-u-v$, si può quindi scrivere:
\begin{equation}
	P = (1-u-v)A + uB + vC
\end{equation}
e sviluppando si ottiene:
\begin{equation}
	P = A-uA-vA+uB+vC = A+u(B-A)+v(C-A)
	\label{eq1}
\end{equation}
Si noti che $(B-A)$ e $(C-A)$ sono i bordi $AB$ e $AC$ del triangolo $ABC$. L'intersezione $P$ può anche essere scritta usando l'equazione parametrica del raggio:
\begin{equation}
	P = R_O + tR_D
	\label{eq2}
\end{equation}
dove $t$ è la distanza dall'origine del raggio all'intersezione $P$. Sostituendo $P$ nell'equazione \ref{eq1} con l'equazione del raggio si ottiene:
\begin{equation}
	\begin{split}
	\begin{align}
		R_O + tR_D =& A+u(B-A)+v(C-A)
		O - A =& -tD+u(B-A)+v(C-A)
	\end{align}
	\end{split}
	\label{eq3}
\end{equation}
Sul membro a sinistra si hanno le tre incognite $(t,u,v)$ moltiplicate per tre termini noti $(B-A, C-A, D)$. Si può riorganizzare questi termini e presentare l'equazione \ref{eq3} usando la seguente notazione:
\begin{equation}
	\begin{bmatrix}
	-D & (B-A) & (C-A)
	\end{bmatrix}
	\begin{bmatrix}
	t \\
	u \\
	v
	\end{bmatrix} = R_O - A
	\label{eq4}
\end{equation}
Si immagini ora di avere un punto $P$ all'interno del triangolo. Se si trasforma il triangolo in qualche modo (ad esempio traslandolo, ruotandolo o scalandolo), le coordinate del punto $P$ espresse nel sistema di coordinate cartesiane tridimensionali $(x,y,z)$ cambieranno. D'altra parte, se si esprime la posizione di $P$ usando le coordinate baricentriche, le trasformazioni applicate al triangolo non influenzeranno le coordinate baricentriche del punto di intersezione. Se il triangolo viene ruotato, ridimensionato, allungato o traslato, le coordinate $(u,v)$ che definiscono la posizione di $P$ rispetto ai vertici $(A,B,C)$ non cambieranno. L'algoritmo di M\"oller-Trumbore sfrutta proprio questa proprietà. Infatti, ciò che gli autori hanno fatto è definire un nuovo sistema di coordinate in cui le coordinate di $P$ non sono definite in termini di $(x,y,z)$ ma in termini di $(u,v)$. La somma tra le coordinate baricentriche non può essere maggiore di 1 ($u + v \leq 1$), esprimono infatti le coordinate dei punti definiti all'interno di un triangolo unitario. Ovvero un triangolo definito nello spazio $(u,v)$ dai vertici $(0,0)$, $(1,0)$, $(0,1)$.

\begin{figure}[htbp]
	\centering
	\hfill
	\begin{subfigure}[t]{.45\linewidth}
		\begin{tikzpicture}
		\coordinate (O) at (0,0,0);
		\def\axisl{3}
		\draw[-stealth] (O) -- (\axisl,0,0) node[below]{$x$};
		\draw[-stealth] (O) -- ({sqrt(\axisl)},{sqrt(\axisl)},0) node[above]{$y$};
		\draw[-stealth] (O) -- (0,\axisl,0) node[left]{$z$};
		\coordinate [label=below:$C$] (V1) at ({\axisl/1.5},0.5,0);
		\coordinate [label=above:$B$] (V2) at ({sqrt(\axisl)/1.5},{3.3/1.8},0);
		\coordinate [label={[shift={(-0.15,0)}]$A$}] (V3) at (0.3,0.6,0);
		\draw[fill=gray!10] (V1) -- (V2) -- (V3) -- (V1);
		
		\def\xp{1};
		\def\yp{1};
		\def\xd{-1};
		\def\yd{0.8};
		\def\mag{1.7};
		\coordinate [label=above:$P$] (P) at (\xp,\yp);
		\coordinate [label={[shift={(-0.3,-0.5)}]$R_D$}] (RD) at (\xp+\xd*1.1,\yp+\yd*1.1);
		\coordinate [label=above:$R_O$] (RO) at (\xp+\xd*\mag*1.1,\yp+\yd*\mag*1.1);
		\draw[fill] (P) circle [radius=1pt];
		\draw[fill] (RO) circle [radius=1pt];
		\draw[-stealth] (RO) -- (RD);
		\draw[dashed] (RD) -- (P);
		\end{tikzpicture}
	\end{subfigure}
	\hfill
	\begin{subfigure}[t]{.45\linewidth}
		\begin{tikzpicture}
		\coordinate (O) at (0,0,0);
		\def\axisl{3}
		\draw[-stealth] (O) -- (\axisl,0,0) node[below]{$\alpha$};
		\draw[-stealth] (O) -- ({sqrt(\axisl)},{sqrt(\axisl)},0) node[above]{$\beta$};
		\draw[-stealth] (O) -- (0,\axisl,0) node[left]{$\gamma$};
		\coordinate [label={[below,font=\tiny]:$1$}] (V1) at ({\axisl/1.5},0,0);
		\coordinate [label={[shift={(-0.1,0.0)},font=\tiny]:$1$}] (V2) at ({sqrt(\axisl)/1.5},{sqrt(\axisl)/1.5},0);
		\coordinate (V3) at (0,0,0);
		\draw[fill=gray!10] (V1) -- (V2) -- (V3) -- (V1);
				
		\def\xp{0.7};
		\def\yp{0.35};
		\def\xd{0};
		\def\yd{1};
		\def\mag{1.7};
		\coordinate [label=right:$P$] (P) at (\xp,\yp);
		\coordinate [label={[shift={(-0.35,-0.15)}]$R_D$}] (RD) at (\xp+\xd,\yp+\yd);
		\coordinate [label=above:$R_O$] (RO) at (\xp+\xd*\mag,\yp+\yd*\mag);
		\draw[fill] (P) circle [radius=1pt];
		\draw[fill] (RO) circle [radius=1pt];
		\draw[-stealth] (RO) -- (RD);
		\draw[dashed] (RD) -- (P);
		\end{tikzpicture}
	\end{subfigure}
	\hfill
	\caption{Transformation and base change of ray in M\"oller-Trumbore algorithm.}
\end{figure}

Geometricamente, si è appena chiarito il significato di $u$ e $v$. Si consideri ora l'elemento $t$. Esso è il terzo asse del sistema di coordinate $u$ e $v$ appena introdotto. Si sà inoltre che $t$ esprime la distanza dall'origine del raggio a $P$, il punto di intersezione, si è quindi creato un sistema di coordinate che consentirà di esprimere univocamente la posizione del punto d'intersezione $P$ in termini di coordinate baricentriche e distanza dall'origine del raggio a quel punto sul triangolo.

M\"oller e Trumbore spiegano che la prima parte dell'equazione \ref{eq4} (il termine $O-A$) può essere vista come una trasformazione che sposta il triangolo dalla sua posizione spaziale mondiale originale all'origine (il primo vertice del triangolo coincide con l'origine). L'altro lato dell'equazione ha l'effetto di trasformare il punto di intersezione dallo spazio $(x,y,z)$ nello spazio $(t,u,v)$ come spiegato precedentemente.

Per risolvere l'equazione \ref{eq4}, M\"oller e Trumbore hanno usato una tecnica conosciuta in matematica come regola di Cramer. La regola di Cramer fornisce la soluzione a un sistema di equazioni lineari mediante il determinante. La regola afferma che se la moltiplicazione di una matrice $M$ per un vettore colonna $X$ è uguale a un vettore colonna $C$, allora è possibile trovare $X_i$ (l'$i$-esimo elemento del vettore colonna $X$) dividendo il determinante di $M_i$ per il determinante di $M$. Dove $M_i$ è la matrice formata sostituendo la sua colonna di $M$ con il vettore colonna $C$. Usando questa regola si ottiene;
\begin{equation}
\begin{bmatrix}
t \\
u \\
v
\end{bmatrix} = 
\frac{1}{\begin{vmatrix}-D & E_1 & E_2\end{vmatrix}}
\begin{bmatrix}
\begin{vmatrix}T & E_1 & E_2\end{vmatrix} \\
\begin{vmatrix}-D & T & E_2\end{vmatrix} \\
\begin{vmatrix}-D & E_1 & T\end{vmatrix}
\end{bmatrix}
\label{eq5}
\end{equation}
dove $T=O-A$, $E_1=B-A$ ed $E_2=C-A$. Il prossimo passo è trovare un valore per questi quattro determinanti. Il determinante (di una matrice $3 \times 3$) non è altro che un triplo prodotto scalare, quindi si può riscrivere l'equazione precedente come:
\begin{equation}
\begin{bmatrix}
t \\
u \\
v
\end{bmatrix} 
= \frac{1}{(D \times E_2) \cdot E_1}
\begin{bmatrix}
(T \times E_1) \cdot E_2 \\
(D \times E_2) \cdot T \\
(T \times E_1) \cdot D
\end{bmatrix}
= \frac{1}{P \cdot E_1}
\begin{bmatrix}
Q \cdot E_2 \\
P \cdot T \\
Q \cdot D
\end{bmatrix}
\end{equation}
dove $P = (D \times E_2)$ e $Q = (T \times E_1)$. Come si può vedere ora è facile trovare i valori $t$, $u$ e $v$.

\begin{figure}
	\hfill
	\begin{subfigure}{.3\linewidth}
		\centering
		\begin{tikzpicture}
		\coordinate (A) at (-1,-0.5);
		\coordinate (B) at (1,1);
		\coordinate (C) at (2.2,-1);
		\draw[fill=gray!10] (A) -- (B) -- (C) -- (A);
		\def\xp{0};
		\def\yp{-0.2};
		\def\xd{0};
		\def\yd{1};
		\def\mag{1.7};
		\coordinate [label=right:\texttt{true}] (P) at (\xp,\yp);
		\coordinate (RD) at (\xp+\xd,\yp+\yd);
		\coordinate (RO) at (\xp+\xd*\mag,\yp+\yd*\mag);
		\draw[fill] (P) circle [radius=1pt];
		\draw[fill] (RO) circle [radius=1pt];
		\draw[-stealth] (RO) -- (RD);
		\draw[dashed] (RD) -- (P);
		\end{tikzpicture}
	\end{subfigure}
	\hfill
	\begin{subfigure}{.3\linewidth}
		\centering
		\begin{tikzpicture}
		\coordinate (A) at (-1,-0.5);
		\coordinate (B) at (1,1);
		\coordinate (C) at (2.2,-1);
		\draw[fill=gray!10] (A) -- (B) -- (C) -- (A);
		\def\xp{0};
		\def\yp{0.25};
		\def\xd{0};
		\def\yd{1};
		\def\mag{1.7};
		\coordinate [label=below right:\texttt{true}] (P) at (\xp,\yp);
		\coordinate (RD) at (\xp+\xd,\yp+\yd);
		\coordinate (RO) at (\xp+\xd*\mag,\yp+\yd*\mag);
		\draw[fill] (P) circle [radius=1pt];
		\draw[fill] (RO) circle [radius=1pt];
		\draw[-stealth] (RO) -- (RD);
		\draw[dashed] (RD) -- (P);
	\end{tikzpicture}
	\end{subfigure}
	\hfill
	\begin{subfigure}{.3\linewidth}
	\centering
	\begin{tikzpicture}
		\coordinate (A) at (-1,-0.5);
		\coordinate (B) at (1,1);
		\coordinate (C) at (2.2,-1);
		\draw[fill=gray!10] (A) -- (B) -- (C) -- (A);
		\def\xp{-0.3};
		\def\yp{0.25};
		\def\xd{0};
		\def\yd{1};
		\def\mag{1.7};
		\coordinate [label=left:\texttt{false}] (P) at (\xp,\yp);
		\coordinate (RD) at (\xp+\xd,\yp+\yd);
		\coordinate (RO) at (\xp+\xd*\mag,\yp+\yd*\mag);
		\draw[fill] (P) circle [radius=1pt];
		\draw[fill] (RO) circle [radius=1pt];
		\draw[-stealth] (RO) -- (RD);
		\draw[dashed] (RD) -- (P);
	\end{tikzpicture}
	\end{subfigure}
	\hfill
	\caption{Schemi per l'\textit{output} dell'intersezione punto-cerchio.}
\end{figure}
\begin{figure}[htbp]
	\centering
	\begin{subfigure}{.65\linewidth}
	\begin{pseudoc}
	E_1 = B - A;
	E_2 = C - A;
	A = R_D $\times$ E_2;
	D = A $\cdot$ E_1;
	if ( D > epsilon ) {
		T = R_0 - A;
		u = A $\cdot$ T;
		if ( u < 0.0 || u > D ) return false;
		B = T $\times$ E_1;
		v = B $\cdot$ R_D;
		if (v < 0.0 || u + v > D) return false;
	} else if ( D < -epsilon ) {
		T = R_0 - A;
		u = A $\cdot$ T;
		if (u > 0.0 || u < D) return false;
		B = T $\times$ E_1;
		v = B $\cdot$ R_D;
		if ( v > 0.0 || u + v < D ) return false;
	} else {
		return false;
	}
	t = ( B $\cdot$ E_2 ) / D;
	if ( t > 0.0 ) {
		P = Q + D * t;
		return true;
	} else {
		return false;
	}
	\end{pseudoc}
	\end{subfigure}
	\caption{Schema per del codice per l'intersezione raggio-triangolo con \textit{back-face culling}.}
\end{figure}